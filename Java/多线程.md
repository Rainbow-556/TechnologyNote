每个线程都有自己的工作内存，对于共享型变量，当某个线程要访问它的时候，会先把这种变量拷贝到自己的工作内存中，之后的读和写操作都是基于线程自身的工作内存，至于什么时候把共享变量的值同步到主存中是无法预知的<br/>

###### 1、volatile作用

**内存可见性**：
读的时候会直接从主存中读，写的时候会直接更新到主存中，只能保证原子操作的内存可见性，比如i++这种不是原子操作，因为先要读取i，再i+1赋值给i，可以使用AtomicInteger代替int
**禁止指令重排序**：

是一种优化代码执行效率的操作，把一些可以提前运行的代码先执行，不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的，例如：

```java
public class Person {
	public String name;
	public Person() {
		this.name = "lx";
	}
}
Person p = new Person();
```
上一行代码总共做了三件事：<br/>
1、分配内存空间<br/>
2、初始化对象，执行构造方法<br/>
3、把p对象的指向上面分配的内存空间地址<br/>
如果发生重排序的话，可能第三步会在第二步之前完成，此时p对象还没完全初始化，从而导致使用p对象时产生错误

###### 2、synchronized

编译后的字节码，会在进入synchronized块之前添加一行monitor.enter的指令，去尝试获取monitor锁，如果成功获取则直接运行，如果该monitor被其他线程占有着，则进入该monitor的等待队列，一旦进入synchronized同步代码块或者同步方法中，会使当前线程对于共享变量的缓存失效，直接读取主存中的值并使用，在退出synchronized代码块时会把共享变量的值刷新到主存中，但是不能保证synchronized之前的执行的结果会立马刷新到主存当中

###### 3、CPU密集型和IO密集型任务

- CPU密集型(计算密集型)

任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。<br/>

计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。<br/>

- IO密集型

涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。<br/>

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

