每个线程都有自己的工作内存，对于共享型变量，当某个线程要访问它的时候，会先把这种变量拷贝到自己的工作内存中，之后的读和写操作都是基于线程自身的工作内存，至于什么时候把
共享变量的值同步到主存中是无法预知的

1、volatile作用
	内存可见性：
		读的时候会直接从主存中读，写的时候会直接更新到主存中，只能保证原子操作的内存可见性，比如i++这种不是原子操作，因为先要读取i，再i+1赋值给i，可以使用AtomicInteger代替int
	禁止指令重排序：是一种优化代码执行效率的操作，把一些可以提前运行的代码先执行，不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的
		例如：
		public class Person {
			public String name;
			public Person() {
				this.name = "lx";
			}
		}
		Person p = new Person();
		上一行代码总共做了三件事：
		1、分配内存空间
		2、初始化对象，执行构造方法
		3、把p对象的指向上面分配的内存空间地址
		如果发生重排序的话，可能第三步会在第二步之前完成，此时p对象还没完全初始化，从而导致使用p对象时产生错误

2、synchronized
	编译后的字节码，会在进入synchronized块之前添加一行monitor.enter的指令，去尝试获取monitor锁，如果成功获取则直接运行，如果该monitor被其他线程占有着，则进入该monitor的等待队列
	一旦进入synchronized同步代码块或者同步方法中，会使当前线程对于共享变量的缓存失效，直接读取主存中的值并使用，在退出synchronized代码块时会把共享变量的值刷新到主存中，
	但是不能保证synchronized之前的执行的结果会立马刷新到主存当中