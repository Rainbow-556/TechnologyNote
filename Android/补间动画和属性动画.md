###### 一、补间动画

View.startAnimation()后调用invalidate()请求重绘，会一直向上遍历到ViewRootImpl，ViewRootImpl会在下一个刷新信号到来时去发起一个measure、layout、draw过程，所以start之后，动画不是立马执行的，而是在下一帧刷新信号到来时才开始执行，在需要做动画的View的draw方法中，会拿到当前View的animation，计算当前animation的运行状态，比如动画执行的进度和是否已经结束等，如果正在进行中，则会把当前的进度回调到animation的applyTransformation()方法中，通过改变Matrix的值，最后在View的draw方法中拿到最新的动画值得Matrix应用到Canvas上(调用的是Canvas.concact()方法)，如果动画还未结束，则会再调用View的invalidate()方法，发起新的一次执行过程，从而达到连续的效果，最终实现动画，只是改变View的绘制影像而已

###### 二、ValueAnimator

ValueAnimator只是一个值生成器，Interpolator插值器的作用是根据动画执行的进度为输入，按照一定的规则计算出动画的执行过程(例如速率，先快后慢等)。ValueAnimator.start()后，会调用AnimationHandler.getInstance().addAnimationFrameCallback()去注册下一帧刷新信号的监听，AnimationHandler通过Choreographer.postFrameCallback()方法来注册下一帧刷新信号的监听，AnimationHandler里有一个ArrayList保存着所有Animator的AnimationFrameCallback，在新的一帧信号到来时，会遍历整个集合，传入当前帧的时间，用于给每个Animator去计算自己的动画进度，结合进度和Interpolator一起计算出当前的animationValue并回调onAnimationUpdate()，当某个Animator已结束时，AnimationHandler会把它从集合中移除<br/>

ObjectAnimator继承于ValueAnimator，复写了animateValue()方法，把最新动画的值通过反射作用到target上